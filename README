router - v4.0.1
--------------------------------------------------------------------------------
This repository provides a class library for routing requests to a PHP
application. The library is designed to be small and minimal.

Primary authors:

    Roger Gee <roger.gee@tulsalibrary.org>

Other authors:

--------------------------------------------------------------------------------
Dependencies:

    n/a

--------------------------------------------------------------------------------
Installation:

This library is available as a composer package. Require 'tccl/router' in your
composer.json file and then install.

You must target at least v3.0.0 to use the composer package.

--------------------------------------------------------------------------------
Classes

    TCCL\Router\Router
        The core routing object type

    TCCL\Router\RequestHandler
        An abstract interface for class-based request handlers
--------------------------------------------------------------------------------
Usage:

Router provides a mechanism for routing control to a handler bdased on the input
URI. It is very easy to setup and use. Just create an instance of type
Router. The constructor takes a handler argument which is the default handler
used when a route does not match;

    function not_found(\TCCL\Router\Router $router) {
        $router->statusCode = 404;
        $router->contentType = \TCCL\Router\Router::CONTENT_TEXT;
        $router->flush();

        echo "Not found\n";
    }

    $router = \TCCL\Router\Router('not_found');

Now you can add routers using the addRoute() method. Each route maps a route to
a handler. A handler is either an object of a type that implements
\TCCL\Router\RequestHandler or a callable. The callable is passed the
\TCCL\Router\Router instance referring the request:

Route URIs may be exact literal routes or PHP regex strings:

    $router->addRoute('GET','/help','generate_help_page');
    $router->addRoute('GET','/\/help\/topics\/([0-9]+)/','generate_help_topic');

Any matches found upon successfully matching a regex path are set in the
router's 'matches' property:

    function generate_help_topic(\TCCL\Router\Router $router) {
        $node = $router->matches[1]; // get second match (first is entire route)

        // ...
    }

Finally we need to route the request. You will have to specify the
URI/method. This is easily obtained via the superglobals set by the
SAPI. Optionally you can specify a base path for the route. This is useful when
your application runs under a subdirectory (i.e. you won't have to change your
routes).

Here is a routing that assumes every route is relative to the document root.

    $router->route($_SERVER['REQUEST_METHOD'],$_SERVER['REQUEST_URI']);

Here is routing that works under an arbitrary base path. This method assumes the
file running the routing code is under the application route directory. Be
careful if this file is a soft link referring to a file outside the application
distribution (it won't work).

    $basePath = substr(dirname(__FILE__),strlen($_SERVER['DOCUMENT_ROOT']));
    $router->route($_SERVER['REQUEST_METHOD'],$_SERVER['REQUEST_URI'],$basePath);
--------------------------------------------------------------------------------
Library Overview:

    [TCCL\Router\RequestHandler]
        run(Router $router)

    [TCCL\Router\Router]
        __construct($notFoundHandler)

            Creates a new instance with the specified fallback handler for
            non-existent routes

        addRoute($method,$uri,$handler)

            Adds a new route to the router; the handler is either a callable or
            a class name/object that implements the RequestHandler interface or
            extends the Router class.

            The $method may be an array of methods or
            \TCCL\Router\Router::HTTP_ALL for all request methods. Supported
            methods include 'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD' and
            'OPTIONS'.

            The $uri is either a literal string route or a regex identifying a
            set of routes to match. Any regex matches will be placed in
            $router->matches. The special route '/' identifies an exact match of
            the base path, which may or may not include a trailing '/'.

            If the handler is a Router subclass/instance, then your $uri should
            be a regex (and exception will be thrown if not). The global match
            will specify the new base path for the subrouter. This means your
            $uri should always specify the base path for the subrouter. For
            example:

                $router->addRoute(Router::HTTP_ALL,'/\/api/','APIRouter');

            In this example, $router will create a subrouter of type APIRouter
            for any path under "/api" (including "/api"). All paths in APIRouter
            will be relative to "/api".

        route($method,$uri,$basedir)

            Routes a request with the specified method and URI

            The base directory specifies the base directory for requests; if
            this value is non-empty, then the router will interpret URIs
            relative to the base directory; for example:

                in route table:

                    "GET" "/A/B" ----> "handler1"

                route "GET" "/base/A/B" with base directory "/base":

                    execute "handler1" since "/base/A/B" matched URI "/A/B" in
                    route table

        addHeader($key,$value)

            Adds header pair to list of headers; header info must be written
            later with a call to flush()

        flush()

            Writes metadata to the output stream; this includes the response
            code, content-type and any headers

        redirect($uri,$params)

            Forces a redirect

            The URI will be evaluated relative to any configured base directory;
            as such this function SHOULD be called in a request handler after a
            call to route()

            Any parameters are encoded and appended to the URI as query parameters

        getURI($component,$params)

            Gets a URI

            The URI will have any configured base path prepended and any
            parameters appended as a query string

        getRequestType()

            Gets the request content type

            The SAPI must have provided this in $_SERVER['CONTENT_TYPE'] or
            $_SERVER['HTTP_CONTENT_TYPE']

        getRequestParam($name,$default = null)

            Gets the named request parameter, returning $default if it is not
            found.
